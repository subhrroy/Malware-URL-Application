# Malware URL Lookup Service

## Problem Statement

We have an HTTP proxy that is scanning traffic, looking for malware URLs. Before allowing HTTP connections to be made, this proxy asks a service that maintains several databases of malware URLs if the resource being requested is known to contain malware.
Write a small web service, preferably in Go or Python, that responds to GET requests where the caller passes in a URL and the service responds with some information about that URL. The GET requests would look like this:
GET /v1/urlinfo/{resource_url_with_query_string}
The caller wants to know if it is safe to access that URL or not. As the implementer, you get to choose the authorization, response format and structure. Please document the API in the README. These lookups are blocking users from accessing the URL until the caller receives a response from your service.
Give some thought to the following. Write-up the design, if you do not have time to code.
•	The size of the URL list could grow infinitely, how might you scale this beyond the memory capacity of the system? Bonus if you implement this.
•	The number of requests may exceed the capacity of this system, how might you solve that? Bonus if you implement this.
•	What are some strategies you might use to update the service with new URLs? Updates may be as many as 5000 URLs a day with updates arriving every 10 minutes.


## Getting Started

These instructions will get you a copy of the project up and running on your local machine for development and testing purposes. 

### Prerequisites

1. Docker installed, Up and Running. 
2. Around 2G of available RAM for Docker containers.
3. Around 2G of free space in the local system. 

### Setup

1. Clone the Project from Git repository. 
2. Git Repo link: 
3. Start the Docker application. 

### Commands
1. docker volume create mongodata ( This creates a local Volume used by MongoDb to store the data )
2. docker-compose up --build ( Spins the containers for url-app, MongoDb and RabbitMq )

## Design Discussion 

The Objective of this application is to design a scalable, high available REST API system that will be validating URLs for malware. 

Points to consider while designing :
* The System is going to scan the network traffic URL for malware. So number of GET request transactions per day will be huge. Assuming ~100K per day. 

 I have chosen Spring Boot to be the primary REST API framework. Spring Boot uses the power of Spring Framework and creates highly scalable microservices.
 There is a GET url available for the consumers which will be taking the URL as the parameter and return a JSON with a Status message and the safety of the URL. 
 GET request looks like 
 http://localhost:9091/v1/urlinfo/get?url=https://www.ttt.com/myside/abcidefo?989899999 or 
 http://localhost:9091/v1/urlinfo/get/www.checkmysafety.com/abc
 
 The System Validates the URL provided to be checked and then validates with the backend database to check the safety of the URL. It returns a JSON like 
 {"Status":"Success","isSafeURI":true} with HTTP 200 Response Code. 
 
 I have implemented MD5 hashing Algorithm on the URL strings. The hash of a particular URL is always the same and it helps in faster indexing and searching in the database.
 
 This is a blocking Synchronous HTTP call. This can handle multiple requests using multi-threading but might be a bottleneck if the number of requests exceed the capacity. For the resolution, please check the next section. 
 
* The number of requests might exceed the capacity of the system 
  The System is designed to handle a particular capacity. But if the load is very high, I'll be implementing Message Queues in the system to handle this scenarios. All the requests are added to the message queue which can be infinite in length. And the system will consume the Queue as per the capacity. This way the underlying system is not overwhelmed with millions of requests and can work efficiently as designed. Few users might find some lag for a short-lived period.

* The size of the URL list could grow infinitely, so we need a high scalable database. 
  We need a highly scalable and fast database. We can use RDBMS which provides acid properties but the problem is scaling. As we have huge traffic, there will be lot of reads. Am not sure RDBMS will scale to this traffic!!!

So I'm using  NoSQL.
NOSQL: As you know the data is eventually consistent, but it is easy to scale and it is a highly available database.
For this application, I have chosen MongoDb as its easy of use and its a demo application. We can use other noSql Dbs like Cassandra, Reddis, Apache Solr, ElastiSearch for even faster enterprise level application.

Note: This system has high read and low writes. We need to keep that in mind while choosing appropriate Datasource. 

* These lookups are blocking users from accessing the URL until the caller receives a response from your service. So the system has to have very low latency and high availability. My choice of datastore for enterprise application would be Cassandra as its one of the Highly Available System.


* Around 5000 urls per day will be added to the system. Approx 5000*30=150,000k updates per month. 
I designed the system as when we update the datastore with new URLs, we use putIfAbsent approach. MongoDb supports the approach. I have used the MD5 hashing algorithm to get the unique key for each url stored in the datastore. The advatage of MD5 hashing algorithm is it reduces the url length to 32 characters only and the hashing is consistent for a URL. This way even if we get same URLs again, we can avoid redundant database calls. 
I have implemented message queue for URL addition in database too. This is implemented using RabbitMQ queue, sender and listener services.  

There is GET REST API url for ADD/UPDATE urls in database too. 
This can be called directly which in turn would push the message in queue, a consumer pulls the message from Queue and completes the insertion/updation. 


## Testing
### Unit Tests
* Unit tests has been added for the REST APIs. 100% code coverage. 

### Running and Testing the Application

* Once the docker compose up comes up, the API system should be available at local port 9091. I have chosen this as 8080,8081 ports are common and might already been occupied. 

* Once the System starts, I add 2 users ( admin & subhro) and 3 URLs in the database. 

* All Rest APIs should be accompanied with Basic Authentication with either of the above mentioned 2 users. 
I haven't exposed User CRUD APIs as this is not in the scope of the problem. We can add CRUD, implement oAuth2 based authentication and authorization if needed. 

* Add/Update of URLs in the database should have Username:admin/Password:admin as credentials for Basic Auth. 
* Get call to know if it is safe to access that URL or not should be accompanied by username:subhro/password:abcd.

* There are schedulers running to simulate pushing and consuming data from rabbitMQ message queue. This can be validated in the terminal console as well in the MongoDb database for updates. 

* Call get API to check malicious URL 

* Add malicious URL in database


## Deployment

CI/CD can be implemented on this system that can deploy the system in any cloud/on-premise/local systems.

## Built With

* Spring Boot
* Apache Maven
* RabbitMq
* MongoDb as database

## Authors

Subhro Jyoti Roy ( subhrroyoffc@gmail.com )